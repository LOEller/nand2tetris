class Snake {

   field SnakeSegment firstSegment;
   field int frameCounter;

   constructor Snake new() {
      // create the head of the snake at (20, 20) moving down
      let firstSegment = SnakeSegment.new(20, 20);
      do setDirection(2);
      let frameCounter = 0;
      return this;
   }

   method void dispose() {
      do firstSegment.dispose(); // recursively deletes all snake segments 
      do Memory.deAlloc(this);
      return;
   }

   method int firstSegmentLeftBound() {
     return firstSegment.getLeftBound();
   }

   method int firstSegmentRightBound() {
     return firstSegment.getRightBound();
   }

   method int firstSegmentTopBound() {
     return firstSegment.getTopBound();
   }

   method int firstSegmentBottomBound() {
     return firstSegment.getBottomBound();
   }

   // Sets direction of the head of the snake 
   // to match whatever direction is input by the user
   method void setDirection(int direction) {
     do firstSegment.setDirection(direction); 
     return;
   }

   // currently this doesn't really work not sure why
   method boolean detectSelfCollision() {
     // determines whether the head of the snake collides with any of its
     // own segments
     var SnakeSegment current;
     let current = firstSegment.getNext();

     // skip the first couple segments to ignore
     if (~(current = null)) {
        let current = firstSegment.getNext();
     } 
     if (~(current = null)) {
        let current = firstSegment.getNext();
     } 

     while (~(current = null)) {
        if (current.getLeftBound() < firstSegment.getRightBound()) {
            if (current.getRightBound() > firstSegment.getLeftBound()) {
                if (current.getTopBound() < firstSegment.getBottomBound()) {
                    if (current.getBottomBound() > firstSegment.getTopBound()) {
                        return true;
                    }
                }
            }
        }
        let current = current.getNext();
     }
     return false;
   }

   method void propagateDirection() {
     // this method propagates the directions back along the 
     // snake from its head to its tail
      var SnakeSegment ahead;
      var SnakeSegment behind;

      let ahead = firstSegment;
      let behind = firstSegment.getNext();

      while (~(behind = null)) {
        // set the next segment's direction to match the one in front of it
        // once it moves in line with the segment ahead 

        // ahead and behind are moving in DIFFERENT directions
        if (~((ahead.getDeltaX() = behind.getDeltaX()) & (ahead.getDeltaY() = behind.getDeltaY()))) {
            // ahead is moving up or down and behind has come to the same x pos as ahead
            if ((ahead.getDeltaX() = 0) & (ahead.getX() = behind.getX())) {
                do behind.setDeltaX(ahead.getDeltaX());
                do behind.setDeltaY(ahead.getDeltaY());
            } else {
                // ahead is moving right or left and behind has come to the same y pos as ahead
                if ((ahead.getDeltaY() = 0) & (ahead.getY() = behind.getY())) {
                    do behind.setDeltaX(ahead.getDeltaX());
                    do behind.setDeltaY(ahead.getDeltaY());
                }
            }
        }

        // move along the snake
        let ahead = behind;
        let behind = behind.getNext();
      }
     return;
   }

   method void eraseMoveDraw() {
     if (frameCounter = 40) {
       do eraseSegments();
       do propagateDirection();
       do moveSegments();
       do drawSegments();
       let frameCounter = 0;
     } else {
        let frameCounter = frameCounter + 1;
     }
     return;
   }

   // goes through the list of snake segments and calls 
   // draw on each one
   method void drawSegments() {
      var SnakeSegment current;
      let current = firstSegment;
      while (~(current = null)) {
        do current.draw();
        let current = current.getNext();
      }
      return;
   }

   // goes through the list of snake segments and calls 
   // erase on each one
   method void eraseSegments() {
      var SnakeSegment current;
      let current = firstSegment;
      while (~(current = null)) {
        do current.erase();
        let current = current.getNext();
      }
      return;
   }

   // goes through the list of snake segments and updates their positions 
   // appropriately
   method void moveSegments() {
      var SnakeSegment current;
      let current = firstSegment;
      while (~(current = null)) {
        do current.move();
        let current = current.getNext();
      }
      return;
   }

   // adds a segment to this snake
   method void addSegment() {
    var SnakeSegment lastSegment; // last segment in the snake 
    var SnakeSegment newSegment; // new segment to add 

    let lastSegment = firstSegment;
    while (~(lastSegment.getNext() = null)) {
      let lastSegment = lastSegment.getNext();
    }

    // create a new segment moving the same direction as the last segment
    // place it one segment-length behind the current tail in the opposite
    // direction that the tail is currently moving
    let newSegment = SnakeSegment.new(
        lastSegment.getX() - (lastSegment.getSize()*lastSegment.getDeltaX()),
        lastSegment.getY() - (lastSegment.getSize()*lastSegment.getDeltaY())
    );
    do newSegment.setDeltaX(lastSegment.getDeltaX());
    do newSegment.setDeltaY(lastSegment.getDeltaY());

    do lastSegment.setNext(newSegment);
    return;
   }
}
