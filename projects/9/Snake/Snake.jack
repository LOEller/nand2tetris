class Snake {

   field SnakeSegment head;
   field SnakeSegment tail;
   field int direction;

   constructor Snake new() {
      var SnakeSegment middle; 

      // start with a three segment snake moving down
      let direction = 2;
      let head = SnakeSegment.new(20, 20);
      let middle = SnakeSegment.new(20, 30);
      let tail = SnakeSegment.new(20, 40);

      // tail -> middle -> head
      do head.setPrev(middle);
      do middle.setNext(head);
      do middle.setPrev(tail);
      do tail.setNext(middle);
      return this;
   }

   method void dispose() {
      do head.dispose(); // recursively deletes all snake segments 
      do Memory.deAlloc(this);
      return;
   }

   method int getLeftBound() {
     return head.getLeftBound();
   }

   method int getRightBound() {
     return head.getRightBound();
   }

   method int getTopBound() {
     return head.getTopBound();
   }

   method int getBottomBound() {
     return head.getBottomBound();
   }

   method void setDirection(int Adirection) {
     let direction = Adirection;
     return;
   }

   method void moveSnake() {
     var SnakeSegment temp;
     var int newX, newY;

     if (direction = 1) {
       let newX = head.getX();
       let newY = head.getY() - 10;
     }
     if (direction = 2) {
       let newX = head.getX();
       let newY = head.getY() + 10;
     }
     if (direction = 3) {
       let newX = head.getX() - 10;
       let newY = head.getY();
     }
     if (direction = 4) {
       let newX = head.getX() + 10;
       let newY = head.getY();
     }

     // append a new head to the snake in the direction the 
     // snake is currently moving and draw

     let temp = SnakeSegment.new(newX, newY); // temp becomes the new head
     do temp.setPrev(head);
     if ((newX + 10 < 510) & (newY + 10 < 254)) {
       if ((newX > 0) & (newY > 0)) {
         do temp.draw();
       }
     }
     do head.setNext(temp);
     let head = temp;

     // erase the tail segment of the snake then delete that node
     let temp = tail;
     let tail = tail.getNext(); // reassign tail pointer
     do temp.erase();
     do Memory.deAlloc(temp); // delete the previous tail
     do tail.setPrev(null);
    
     return;
   }


   // adds a segment to this snake
   method void addSegment() {
    var SnakeSegment temp;
    var int newX, newY;

    if (direction = 1) {
      let newX = head.getX();
      let newY = head.getY() - 10;
    }
    if (direction = 2) {
      let newX = head.getX();
      let newY = head.getY() + 10;
    }
    if (direction = 3) {
      let newX = head.getX() - 10;
      let newY = head.getY();
    }
    if (direction = 4) {
      let newX = head.getX() + 10;
      let newY = head.getY();
    }

    let temp = SnakeSegment.new(newX, newY);
    do temp.setPrev(head);
    do head.setNext(temp);
    let head = temp;
    do head.draw();
    return;
   }


   /*
   // currently this doesn't really work not sure why
   method boolean detectSelfCollision() {
     // determines whether the head of the snake collides with any of its
     // own segments
     var SnakeSegment current;
     let current = firstSegment.getNext();

     // skip the first couple segments to ignore
     if (~(current = null)) {
        let current = firstSegment.getNext();
     } 
     if (~(current = null)) {
        let current = firstSegment.getNext();
     } 

     while (~(current = null)) {
        if (current.getLeftBound() < firstSegment.getRightBound()) {
            if (current.getRightBound() > firstSegment.getLeftBound()) {
                if (current.getTopBound() < firstSegment.getBottomBound()) {
                    if (current.getBottomBound() > firstSegment.getTopBound()) {
                        return true;
                    }
                }
            }
        }
        let current = current.getNext();
     }
     return false;
   }
   */
}
